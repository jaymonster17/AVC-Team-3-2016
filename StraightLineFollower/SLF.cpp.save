#include <stdio.h>
#include <time.h>
#include <signal.h>
#include <stdlib.h>

//these load specific methods from the ENGR101 library
extern "C" int init(int d_lev);
extern "C" int take_picture();
extern "C" char get_pixel(int row, int col, int colour);
extern "C" int Sleep(int sec, int usec);
extern "C" int set_motor(int motor, int speed);
extern "C" int connect_to_server(char const server_addr[15], int port);
extern "C" int send_to_server(char const message[24]);
extern "C" int receive_from_server(char const message[24]);
extern "C" int read_analog(int ch_adc);

int THRESHOLD = 125;
#define NTP 32

// Global Variables

int width = 320;
int height = 240;
double dx = width / NTP;
double dy = height / NTP;
int midPic[NTP];
int leftPic[NTP];
int rightPic[NTP];
int redPic;
int zeroCentre[] = { -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
int n_whites_mid = 0;
int n_whites_left = 0;
int n_whites_right = 0;

int method = 1;
int gate_test = 1;

// PID
double error_mid = 0.0;
double Perror_mid = 0.0;
double Pconstant = 1.75; // correcting speed (proportional to distance away from line)
double Dconstant = 340; // Change later

struct timespec now;
double proportional = error_mid * Pconstant; // error correction for adjusting motor speed
double now_ms = 0;
double prev_ms = 0;
double delta_ms = 0;
double derivative = 0;
double Tcorrection = proportional + derivative;

//Motor Control
int speed = 0;
double v_left = speed - (Tcorrection); //speed of left motor
double v_right = speed + (Tcorrection); // speed of right motor

// Maze IR Sensors
int sensor_left;
int sensor_mid;
int sensor_right;

// Prototypes
void terminate(int);
void Quad3Process();
void GeneralPID();

int main()
{
    init(0);
    signal(SIGINT, terminate);
    signal(SIGTERM, terminate);

    if (gate_test == 1) {
        //connects to server with the ip address 130.195.6.196
        connect_to_server("130.195.6.196", 1024);
        //sends a message to the connected server
        send_to_server("Please"); // "Please is the 'codeword', may change
        //receives message from the connected server
        char message[24];
        receive_from_server(message);
        send_to_server(message); // send password back to server to open up gate.
    }

    Sleep(1, 000000);
    speed = 90;

    v_left = speed - Tcorrection; // speed of left motor
    v_right = speed + Tcorrection; // speed of right motor

    // Method for completing quadrant 1
    while (method == 1) {
        Dconstant = 340;
        clock_gettime(CLOCK_REALTIME, &now);
        prev_ms = (now.tv_sec * 1000 + (now.tv_nsec + 500000) / 1000000); //convert to milliseconds
        take_picture();
        n_whites_mid = 0;
        for (int i = 0; i < NTP; i++) {
            int x = dx * i + (dx / 2);
            midPic[i] = get_pixel(x, 1, 3);

            if (midPic[i] > THRESHOLD) {
                // 1 = white
                midPic[i] = 1;
                n_whites_mid++;
            }
            else {
                // 0 = black
                midPic[i] = 0;
            }
        }

        // reset variables
        error_mid = 0.0;

        for (int l = 0; l < NTP; l++) {
            error_mid = error_mid + (zeroCentre[l] * midPic[l]);
        }

        if (n_whites_mid != 0 && n_whites_mid != NTP) {
            GeneralPID();
        }

        else if (n_whites_mid == NTP) {
            method = 2;
        }

        else if (n_whites_mid == 0) {
            // if loses line, swings quickly to direction of last error of line seen
            if (Perror_mid > 0) {
                // hard left
                v_left = -15;
                v_right = 40;
            }

            else if (Perror_mid < 0) {
                // hard right
                v_left = 40;
                v_right = -15;
            }
        }

        Perror_mid = error_mid;
        clock_gettime(CLOCK_REALTIME, &now);
        now_ms = (now.tv_sec * 1000 + (now.tv_nsec + 500000) / 1000000); //convert to milliseconds

        delta_ms = now_ms - prev_ms;
        set_motor(1, v_left);
        set_motor(2, v_right);
    }

    // method for completing quadrant 3
    while (method == 2) {

        speed = 65;
        Pconstant = 0.6;
        Dconstant = 375;
        clock_gettime(CLOCK_REALTIME, &now);
        prev_ms = (now.tv_sec * 1000 + (now.tv_nsec + 500000) / 1000000); //convert to milliseconds
        take_picture();
        n_whites_mid = 0;
        n_whites_left = 0;
        n_whites_right = 0;
        sensor_right = read_analog(2);
        for (int i = 0; i < NTP; i++) {
            int x = dx * i + (dx / 2);
            int y = dy * i + (dy / 2);
            midPic[i] = get_pixel(x, 1, 3);
            leftPic[i] = get_pixel(1, y, 3);
            rightPic[i] = get_pixel(319, y, 3);
            if (midPic[i] > THRESHOLD) {
                // 1 = white
                midPic[i] = 1;
                n_whites_mid++;
            }
            else {
                // 0 = black
                midPic[i] = 0;
            }

            if (leftPic[i] > THRESHOLD) {
                // 1 = white
                leftPic[i] = 1;
                n_whites_left++;
            }
            else {
                // 0 = black
                leftPic[i] = 0;
            }

            if (rightPic[i] > THRESHOLD) {
                // 1 = white
                rightPic[i] = 1;
                n_whites_right++;
            }
            else {
                // 0 = black
                rightPic[i] = 0;
            }

            if (sensor_right > 300) {
                method = 3;
            }
        }
        // reset variables
        error_mid = 0.0;
        for (int l = 0; l < NTP; l++) {
            error_mid = error_mid + zeroCentre[l] * midPic[l];
        }

        // t junction
        if (midPic[16] == 0 && n_whites_left != 0 && n_whites_right != 0) {
            v_left = speed;
            v_right = speed;
            set_motor(2, v_right);
            set_motor(1, v_left);
            Sleep(0, 200000);

            while (midPic[16] == 0) {
                Quad3Process(); // calls method to take image and process values
                v_left = speed;
                v_right = -0.7 * speed;
                set_motor(2, v_right);
                set_motor(1, v_left);
            }
        }
        // left turn
        else if (midPic[16] == 0 && n_whites_left != 0 && n_whites_right < 5) {
            v_left = speed;
            v_right = speed;
            set_motor(2, v_right);
            set_motor(1, v_left);
            Sleep(0, 200000);

            while (midPic[16] == 0) {
                Quad3Process();
                v_left = speed;
                v_right = -0.7 * speed;
                set_motor(2, v_right);
                set_motor(1, v_left);
            }
        }
        //right turn
        else if (midPic[16] == 0 && n_whites_left < 5 && n_whites_right != 0) {
            v_left = speed;
            v_right = speed;
            set_motor(2, v_right);
            set_motor(1, v_left);
            Sleep(0, 200000);

            while (midPic[16] == 0) {
                Quad3Process();
                v_left = speed;
                v_right = -0.7 * speed;
                set_motor(1, v_right);
                set_motor(2, v_left);
            }
        }
        // dead end - should do 180
        else if (n_whites_mid == 0 && n_whites_left == 0 && n_whites_right == 0) {
            while (midPic[16] == 0) {
                Quad3Process();
                v_left = -speed;
                v_right = speed;
                set_motor(1, v_right);
                set_motor(2, v_left);
            }
        }

        // pid
        else if (n_whites_mid != 0 && n_whites_mid != NTP) {
            GeneralPID();
        }

        else if (n_whites_mid == 0) {
            v_left = 45;
            v_right = 45;
        }

        Perror_mid = error_mid;
        clock_gettime(CLOCK_REALTIME, &now);
        now_ms = (now.tv_sec * 1000 + (now.tv_nsec + 500000) / 1000000); //convert to milliseconds
        delta_ms = now_ms - prev_ms;
        set_motor(1, v_left);
        set_motor(2, v_right);
    }

